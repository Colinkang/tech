### mysql高性能
* mysql 设计--存储引擎架构
* 索引 优化
* 查询语句 优化
* 事务 
* 锁
* 集群化
* 日志
* 分表


* 并发控制
  * 读写锁
  * 共享锁(读锁) 排他锁(写锁)
  * 获得锁，检查锁是否已经解除，释放锁，都需要增加系统的开销
  * 所谓锁策略，就是在锁的开销和数据的安全性之间寻求平衡。
  * 表锁：Mysql最基本的锁策略，并且是开销最小的策略。
  * 行级锁：可以最大程度地支持并发处理(同时也带来了最大的开销)。
  * 事务：事务就是一组原子性的SQL查询，或者说一个独立的工作单元
  * 原子性 一致性 隔离性 持久性
  * 死锁 两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源
  * InnoDB目前的处理死锁的办法：将持有最少行排它锁的事务进行回滚
* 事务日志
  使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再    把该修改行为记录到持久在硬盘的事务日志中，而不用每次都将修改的数据本身持久到磁盘。
  * 多版本并发控制(MVCC)
  * innodb引擎
  * mysql拥有分层的架构。上层是服务器层的服务和查询执行引擎，下层则是存储引擎。如果能理解mysql在存储引擎和服务层之间处理查询时如何通过API来
### Mysql基准测试
* 基准测试是针对系统设计的一种压力测试。通常的目标是为了掌握系统的行为。
* 基准测试的策略 集成式以及单组件式基准测试
* 吞吐量:单位时间内的事务处理数
* 响应时间:用于测试任务所需的整体时间
* 并发性：web服务器并发性 数据库并发性
* 可扩展性:给系统增加一倍的工作，在理想情况下就能获得两倍的结果。或者说，给系统增加一倍的资源，就可以获得两倍的吞吐量
* sysbench基准测试
### Schema与数据类型优化
* 逻辑设计 物理设计 查询执行
* 设计原则
  1. 更小的通常更好(一般情况下，应该尽量使用可以正确存储数据的最小数据类型)
  2. 简单就好
  3. 尽量避免NULL
 * 整数类型 tinyint，smallint mediumint int bigint
 * 范式和反范式
 * 缓存表 汇总表
### 索引
* 索引是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单
### sql
[sql exercise](https://github.com/XD-DENG/SQL-exercise/blob/master/SQL_exercise_8_solution_NOT_given_yet/8_build_schema.sql)
[mysql资源](https://github.com/jobbole/awesome-mysql-cn)
快照读：读取的是记录的可见版本，不用加锁
当前读：读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事物不会再并发修改这条记录


customer seller合并在一个app中

* 修改表名
  alter table emp rename emp2
  [swift](https://www.raywenderlich.com/category/swift)
  



